.\" Automatically generated by Pod::Man version 1.02
.\" Thu Aug 16 15:51:43 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Convert 3"
.TH Convert 3 "perl v5.6.0" "2001-08-16" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Finance::Currency::Convert \-
Convert currencies and fetch their exchange rates (with Finance::Quote)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Finance::Currency::Convert;
\&   my $converter = new Finance::Currency::Convert;
.Ve
.Vb 3
\&   $amount_euro = $converter->convert(100, "DEM", "EUR");
\&   $amount_euro = $converter->convertToEuro(100, "DEM");
\&   $amount_dem = $converter->convertFromEuro(100, "DEM");
.Ve
.Vb 1
\&   $converter->updateRates("EUR", "DEM", "USD");
.Ve
.Vb 2
\&   $converter->setRatesFile(".rates");
\&   $converter->writeRatesFile();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module converts currencies. It has built in the fixed exchange
rates for all Euro currencies (as of November 2000). If you wish to use other / more
currencies, you can automatically fetch their exchange rates from
the internet and (optionally) store them in a file for later reference.
.PP
Use this module if you have large volumes of currency data to convert.
Using the exchange rates from memory makes it a lot faster than
using Finance::Quote directly and will save you the duty of storing
the exchange rates yourself.
.Sh "\s-1CURRENCY\s0 \s-1SYMBOLS\s0"
.IX Subsection "CURRENCY SYMBOLS"
Finance::Currency::Convert uses the three character \s-1ISO\s0 currency codes
used by  Finance::Quote.
Here is a list of currency codes.
.PP
Currencies with built-in rates (complete):
.PP
.Vb 13
\&        EUR             Euro
\&        ATS             Austrian Schilling
\&        BEF             Belgiam Franc
\&        DEM             German Mark
\&        ESP             Spanish Peseta
\&        FIM             Finnish Mark
\&        FRF             French Franc
\&        GRD             Greek Drachma
\&        IEP             Irish Punt
\&        ITL             Italian Lira
\&        LUF             Luxembourg Franc
\&        NLG             Dutch Guilder
\&        PTE             Portuguese Escudo
.Ve
Other currencies (incomplete):
.PP
.Vb 5
\&        AUD             Australian Dollar
\&        CHF             Swiss Franc
\&        HKD             Hong Kong Dollar
\&        JPY             Japanese Yen
\&        USD             US Dollar
.Ve
.SH "AVAILABLE METHODS"
.IX Header "AVAILABLE METHODS"
.Sh "\s-1NEW\s0"
.IX Subsection "NEW"
.Vb 1
\&   my $converter = new Finance::Currency::Convert;
.Ve
The newly created conversion object will by default only know how to
convert Euro currencies. To \*(L"teach\*(R" it more currencies use updateRates.
.Sh "\s-1CONVERT\s0"
.IX Subsection "CONVERT"
.Vb 1
\&   $amount_euro = $converter->convert(100, "DEM", "EUR");
.Ve
This will convert 100 German Marks into the equivalent
amount Euro.
.Sh "\s-1CONVERTTOEURO\s0"
.IX Subsection "CONVERTTOEURO"
.Vb 1
\&   $amount_euro = $converter->convertToEuro(100, "DEM");
.Ve
This will convert 100 German Marks into the equivalent amount Euro.
This function is simply shorthand for calling convert directly with
\&\*(L"\s-1EUR\s0\*(R" als the second (target) currency.
.Sh "\s-1CONVERTFROMEURO\s0"
.IX Subsection "CONVERTFROMEURO"
.Vb 1
\&   $amount_dem = $converter->convertFromEuro(100, "DEM");
.Ve
This will convert 100 Eurointo the equivalent amount German Marks.
This function is simply shorthand for calling convert directly with
\&\*(L"\s-1EUR\s0\*(R" als the first (source) currency.
.Sh "\s-1UPDATERATES\s0"
.IX Subsection "UPDATERATES"
.Vb 2
\&   $converter->updateRates("USD");
\&   $converter->updateRates("EUR", "DEM", "USD");
.Ve
This will fetch the exchange rates for one or more currencies using
Finance::Quote and update the exchange rates in memory.
This method will fetach all combinations of exchange rates between
the named currencies and the ones already in memory.
This may result in a large number of requests to Finance::Quote.
To avoid network overhead you can store the retrieved rates with
\&\fIsetRatesFile()\fR / \fIwriteRatesFile()\fR once you have retrieved them
and load them again with \fIsetRatesFile()\fR.
.Sh "\s-1SETUSERAGENT\s0"
.IX Subsection "SETUSERAGENT"
.Vb 1
\&        $converter->setUserAgent("MyCurrencyAgent 1.0");
.Ve
Set the user agent string to be used by Finance::Quote.
.Sh "\s-1SETRATE\s0"
.IX Subsection "SETRATE"
.Vb 1
\&        $converter->setRate("EUR", "USD", 999);
.Ve
Set one exchange rate. Used internally by updateRates,
but may be of use if you have to add a rate manually.
.Sh "\s-1SETRATESFILE\s0"
.IX Subsection "SETRATESFILE"
.Vb 1
\&   $converter->setRatesFile(".rates");
.Ve
Name the file where exchange rates are stored. If it already exists
it will be read into memory.
.Sh "\s-1READRATESFILE\s0"
.IX Subsection "READRATESFILE"
.Vb 1
\&   $converter->readRatesFile();
.Ve
Usually called internally by setRatesFile, but may also be called
directly to revert to the rates stored in the file.
Calling \fIreadRatesFile()\fR will erase all existing exchange rates in memory.
.Sh "\s-1WRITERATESFILE\s0"
.IX Subsection "WRITERATESFILE"
.Vb 1
\&   $converter->writeRatesFile();
.Ve
Call this function to save table with exchange rates from memory
to the file named by \fIsetRatesFile()\fR eg. after fetching new rates
with updateRates.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\&  Jan Willamowius <jan@willamowius.de>, http://www.willamowius.de
\&    with help from many nice colleagues at http://www.mobile.de
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Finance::Quote
.PP
This module is only needed for fetching exchange rates.
There is no need to install it when only Euro currencies are used.
